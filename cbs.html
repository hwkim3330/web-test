<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CBS Control - VelocityDRIVE-SP</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      color: #fff;
      padding: 20px;
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
    }
    h1 {
      text-align: center;
      margin-bottom: 30px;
      font-size: 1.8rem;
      color: #00d4ff;
    }
    .panel {
      background: rgba(255,255,255,0.05);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 20px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
    }
    .panel h2 {
      font-size: 1rem;
      color: #00d4ff;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .status-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ff4757;
      animation: pulse 2s infinite;
    }
    .status-indicator.connected {
      background: #2ed573;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
      transition: all 0.2s;
    }
    .btn-primary {
      background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
      color: #1a1a2e;
    }
    .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0,212,255,0.4); }
    .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    .btn-danger {
      background: linear-gradient(135deg, #ff4757 0%, #cc0000 100%);
      color: #fff;
    }
    .btn-secondary {
      background: rgba(255,255,255,0.1);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.2);
    }
    .form-group {
      margin-bottom: 16px;
    }
    .form-group label {
      display: block;
      font-size: 0.85rem;
      color: #a0a0a0;
      margin-bottom: 6px;
    }
    select, input[type="number"] {
      width: 100%;
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      background: rgba(0,0,0,0.3);
      color: #fff;
      font-size: 1rem;
    }
    select:focus, input:focus {
      outline: none;
      border-color: #00d4ff;
    }
    .port-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 8px;
      margin-bottom: 16px;
    }
    .port-btn {
      padding: 12px 8px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
    }
    .port-btn:hover { border-color: #00d4ff; }
    .port-btn.selected {
      background: rgba(0,212,255,0.2);
      border-color: #00d4ff;
      color: #00d4ff;
    }
    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }
    .presets {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }
    .preset-btn {
      padding: 8px 12px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      color: #fff;
      cursor: pointer;
      font-size: 0.8rem;
    }
    .preset-btn:hover { background: rgba(255,255,255,0.2); }
    .log-area {
      background: #0d1117;
      border-radius: 8px;
      padding: 12px;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 0.75rem;
      height: 200px;
      overflow-y: auto;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .log-line { margin-bottom: 4px; opacity: 0.8; }
    .log-line.error { color: #ff4757; }
    .log-line.success { color: #2ed573; }
    .log-line.info { color: #00d4ff; }
    .log-line.tx { color: #ffa502; }
    .log-line.rx { color: #7bed9f; }
    .action-row {
      display: flex;
      gap: 12px;
      margin-top: 20px;
    }
    .action-row .btn { flex: 1; }
    .info-text {
      font-size: 0.8rem;
      color: #666;
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>CBS Control</h1>

    <div class="panel">
      <h2><span class="status-indicator" id="statusDot"></span> Connection</h2>
      <button class="btn btn-primary" id="connectBtn" onclick="toggleConnection()">
        Connect Serial Port
      </button>
      <p class="info-text" id="deviceInfo">Web Serial API - Chrome/Edge required</p>
    </div>

    <div class="panel">
      <h2>Port Selection</h2>
      <div class="port-grid" id="portGrid"></div>
      <div class="presets">
        <button class="preset-btn" onclick="selectPorts([1,2,3,4])">Ports 1-4</button>
        <button class="preset-btn" onclick="selectPorts([5,6,7,8])">Ports 5-8</button>
        <button class="preset-btn" onclick="selectPorts([9,10,11,12])">Ports 9-12</button>
        <button class="preset-btn" onclick="selectAllPorts()">All Ports</button>
        <button class="preset-btn" onclick="clearPorts()">Clear</button>
      </div>
    </div>

    <div class="panel">
      <h2>CBS Configuration</h2>
      <div class="form-row">
        <div class="form-group">
          <label>Traffic Class (0-7)</label>
          <select id="trafficClass">
            <option value="7">TC 7 (Highest Priority)</option>
            <option value="6">TC 6</option>
            <option value="5">TC 5</option>
            <option value="4">TC 4</option>
            <option value="3">TC 3</option>
            <option value="2">TC 2</option>
            <option value="1">TC 1</option>
            <option value="0">TC 0 (Best Effort)</option>
          </select>
        </div>
        <div class="form-group">
          <label>Idle Slope (kbps)</label>
          <input type="number" id="idleSlope" value="100000" min="0" max="1000000" step="1000">
        </div>
      </div>
      <div class="presets">
        <button class="preset-btn" onclick="setIdleSlope(10000)">10 Mbps</button>
        <button class="preset-btn" onclick="setIdleSlope(50000)">50 Mbps</button>
        <button class="preset-btn" onclick="setIdleSlope(100000)">100 Mbps</button>
        <button class="preset-btn" onclick="setIdleSlope(250000)">250 Mbps</button>
        <button class="preset-btn" onclick="setIdleSlope(500000)">500 Mbps</button>
      </div>
      <div class="action-row">
        <button class="btn btn-primary" id="applyBtn" onclick="applyCBS()" disabled>Apply CBS</button>
        <button class="btn btn-danger" id="clearBtn" onclick="clearCBS()" disabled>Clear CBS</button>
      </div>
    </div>

    <div class="panel">
      <h2>Log</h2>
      <div class="log-area" id="logArea"></div>
      <button class="btn btn-secondary" onclick="clearLog()" style="margin-top:12px">Clear Log</button>
    </div>
  </div>

  <script>
    // ============================================
    // YANG SID Definitions (from mchp-velocitysp-port SID file)
    // ============================================
    const SID = {
      TRAFFIC_CLASS_SHAPERS: 8051,  // /interfaces/interface/eth-qos/config/traffic-class-shapers
      TRAFFIC_CLASS: 8052,          // traffic-class (key leaf)
      CREDIT_BASED: 8053,           // credit-based container
      IDLE_SLOPE: 8054,             // idle-slope leaf
    };

    // ============================================
    // MUP1 Protocol (Microchip UART Protocol 1)
    // ============================================
    const MUP1 = {
      SOF: 0x3e,  // '>'
      EOF: 0x3c,  // '<'
      ESC: 0x5c,  // '\'

      calcChecksum(data) {
        let sum = 0;
        for (const b of data) sum += b;
        const checksum = (~sum) & 0xffff;
        return checksum.toString(16).padStart(4, '0').toUpperCase();
      },

      encode(type, payload) {
        const frame = [this.SOF, type.charCodeAt(0)];
        for (const b of payload) {
          if (b === this.SOF || b === this.EOF || b === this.ESC) {
            frame.push(this.ESC, b);
          } else {
            frame.push(b);
          }
        }
        frame.push(this.EOF);
        if ((frame.length - 1) % 2 === 0) frame.push(this.EOF);
        const checksumData = frame.slice(1, -1);
        if (frame[frame.length-1] === this.EOF && frame[frame.length-2] === this.EOF) {
          checksumData.pop();
        }
        const checksum = this.calcChecksum(checksumData);
        for (const c of checksum) frame.push(c.charCodeAt(0));
        return new Uint8Array(frame);
      },

      createPing() {
        return this.encode('p', []);
      },

      // Parser state machine
      state: 'IDLE',
      buffer: [],

      reset() {
        this.state = 'IDLE';
        this.buffer = [];
      },

      parse(bytes) {
        const frames = [];
        for (const b of bytes) {
          switch (this.state) {
            case 'IDLE':
              if (b === this.SOF) {
                this.buffer = [];
                this.state = 'DATA';
              }
              break;
            case 'DATA':
              if (b === this.ESC) {
                this.state = 'ESCAPE';
              } else if (b === this.EOF) {
                this.state = 'EOF1';
              } else {
                this.buffer.push(b);
              }
              break;
            case 'ESCAPE':
              this.buffer.push(b);
              this.state = 'DATA';
              break;
            case 'EOF1':
              if (b === this.EOF) {
                this.state = 'CHECKSUM';
              } else if ((b >= 0x30 && b <= 0x39) || (b >= 0x41 && b <= 0x46) || (b >= 0x61 && b <= 0x66)) {
                this.state = 'CHECKSUM';
                this.buffer.push(b);
              } else {
                this.state = 'IDLE';
              }
              break;
            case 'CHECKSUM':
              this.buffer.push(b);
              if (this.buffer.length >= 4) {
                const typeChar = String.fromCharCode(this.buffer[0]);
                const data = new Uint8Array(this.buffer.slice(1, -4));
                frames.push({ type: typeChar, data });
                this.state = 'IDLE';
                this.buffer = [];
              }
              break;
          }
        }
        return frames;
      }
    };

    // ============================================
    // CoAP Protocol
    // ============================================
    const CoAP = {
      CODE_GET: 1,
      CODE_IPATCH: 7,
      TYPE_CON: 0,
      FORMAT_YANG_INSTANCES_CBOR: 142,
      msgId: Math.floor(Math.random() * 65536),

      buildFrame(method, path, payload = null) {
        const frame = [];
        // Header
        frame.push(0x41);  // Ver=1, Type=CON, TKL=1
        frame.push(method);
        frame.push((this.msgId >> 8) & 0xff, this.msgId++ & 0xffff);
        frame.push(0x00);  // Token

        // Options
        let lastOpt = 0;
        // URI-Path (11)
        for (const p of path.split('/').filter(x => x)) {
          const delta = 11 - lastOpt;
          frame.push((delta << 4) | p.length);
          for (const c of p) frame.push(c.charCodeAt(0));
          lastOpt = 11;
        }
        // Content-Format (12)
        if (payload) {
          frame.push(0x11, this.FORMAT_YANG_INSTANCES_CBOR);
          lastOpt = 12;
        }
        // Block2 (23)
        const b2delta = 23 - lastOpt;
        frame.push((b2delta << 4) | 1, 0x04);  // num=0, m=0, szx=4 (256 bytes)

        // Payload
        if (payload) {
          frame.push(0xff);
          frame.push(...payload);
        }

        return new Uint8Array(frame);
      },

      parseResponse(data) {
        if (data.length < 4) return null;
        const code = data[1];
        const codeClass = (code >> 5) & 0x7;
        const codeDetail = code & 0x1f;
        return { codeClass, codeDetail, code: `${codeClass}.${codeDetail.toString().padStart(2,'0')}` };
      }
    };

    // ============================================
    // CBOR Encoder (minimal)
    // ============================================
    function encodeCBOR(value) {
      const result = [];

      function encode(v) {
        if (v === null) { result.push(0xf6); return; }
        if (typeof v === 'number' && Number.isInteger(v)) {
          if (v >= 0) {
            if (v < 24) result.push(v);
            else if (v < 256) result.push(0x18, v);
            else if (v < 65536) result.push(0x19, v >> 8, v & 0xff);
            else result.push(0x1a, (v >> 24) & 0xff, (v >> 16) & 0xff, (v >> 8) & 0xff, v & 0xff);
          }
          return;
        }
        if (typeof v === 'string') {
          const bytes = new TextEncoder().encode(v);
          if (bytes.length < 24) result.push(0x60 | bytes.length);
          else result.push(0x78, bytes.length);
          result.push(...bytes);
          return;
        }
        if (Array.isArray(v)) {
          if (v.length < 24) result.push(0x80 | v.length);
          else result.push(0x98, v.length);
          for (const item of v) encode(item);
          return;
        }
        if (typeof v === 'object') {
          const keys = Object.keys(v);
          if (keys.length < 24) result.push(0xa0 | keys.length);
          else result.push(0xb8, keys.length);
          for (const k of keys) {
            const numKey = parseInt(k);
            encode(isNaN(numKey) ? k : numKey);
            encode(v[k]);
          }
          return;
        }
      }

      encode(value);
      return new Uint8Array(result);
    }

    // ============================================
    // Build CBS iPATCH Payload
    // ============================================
    function buildCBSPayload(portName, trafficClass, idleSlope) {
      // iPATCH format: { IID => value }
      // IID = [SID, key1, key2, ...] - SID of target list + parent list keys
      // For traffic-class-shapers: IID = [8051, portName]
      //   - 8051 = SID of traffic-class-shapers
      //   - portName = key of parent /interfaces/interface list
      // Value = array of list entries with delta-SID encoded fields

      // Build IID: [SID, interface-name-key]
      const iid = [SID.TRAFFIC_CLASS_SHAPERS, portName];

      // Build value: array of shaper entries
      // Each entry has delta-SID encoded fields:
      //   traffic-class: delta = 8052 - 8051 = 1
      //   credit-based: delta = 8053 - 8051 = 2
      //     idle-slope: delta = 8054 - 8053 = 1
      const deltaTc = SID.TRAFFIC_CLASS - SID.TRAFFIC_CLASS_SHAPERS;  // 1
      const deltaCb = SID.CREDIT_BASED - SID.TRAFFIC_CLASS_SHAPERS;   // 2
      const deltaIs = SID.IDLE_SLOPE - SID.CREDIT_BASED;              // 1

      const value = [{
        [deltaTc]: trafficClass,
        [deltaCb]: {
          [deltaIs]: idleSlope
        }
      }];

      // Encode as CBOR map: { array => value }
      const result = [];
      result.push(0xa1);  // map(1)

      // Encode IID (array)
      result.push(0x82);  // array(2)
      result.push(0x19, (SID.TRAFFIC_CLASS_SHAPERS >> 8) & 0xff, SID.TRAFFIC_CLASS_SHAPERS & 0xff);  // uint16
      const nameBytes = new TextEncoder().encode(portName);
      result.push(0x60 | nameBytes.length);  // text string
      result.push(...nameBytes);

      // Encode value (array of maps)
      const valueBytes = encodeCBOR(value);
      result.push(...valueBytes);

      return new Uint8Array(result);
    }

    // ============================================
    // Application State
    // ============================================
    let port = null;
    let writer = null;
    let reader = null;
    let selectedPorts = new Set();
    let connected = false;

    // ============================================
    // UI Functions
    // ============================================
    function initUI() {
      const grid = document.getElementById('portGrid');
      for (let i = 1; i <= 12; i++) {
        const btn = document.createElement('button');
        btn.className = 'port-btn';
        btn.textContent = `Port ${i}`;
        btn.onclick = () => togglePort(i, btn);
        grid.appendChild(btn);
      }
      log('CBS Control initialized', 'info');
      log('Click "Connect Serial Port" to begin', 'info');
    }

    function togglePort(num, btn) {
      if (selectedPorts.has(num)) {
        selectedPorts.delete(num);
        btn.classList.remove('selected');
      } else {
        selectedPorts.add(num);
        btn.classList.add('selected');
      }
    }

    function selectPorts(ports) {
      clearPorts();
      const btns = document.querySelectorAll('.port-btn');
      ports.forEach(p => {
        if (p >= 1 && p <= 12) {
          selectedPorts.add(p);
          btns[p-1].classList.add('selected');
        }
      });
    }

    function selectAllPorts() {
      selectPorts([1,2,3,4,5,6,7,8,9,10,11,12]);
    }

    function clearPorts() {
      selectedPorts.clear();
      document.querySelectorAll('.port-btn').forEach(b => b.classList.remove('selected'));
    }

    function setIdleSlope(value) {
      document.getElementById('idleSlope').value = value;
    }

    function log(msg, type = '') {
      const area = document.getElementById('logArea');
      const time = new Date().toLocaleTimeString();
      const line = document.createElement('div');
      line.className = 'log-line ' + type;
      line.textContent = `[${time}] ${msg}`;
      area.appendChild(line);
      area.scrollTop = area.scrollHeight;
      while (area.children.length > 200) area.removeChild(area.firstChild);
    }

    function clearLog() {
      document.getElementById('logArea').innerHTML = '';
    }

    function setConnected(state) {
      connected = state;
      document.getElementById('statusDot').classList.toggle('connected', state);
      document.getElementById('connectBtn').textContent = state ? 'Disconnect' : 'Connect Serial Port';
      document.getElementById('applyBtn').disabled = !state;
      document.getElementById('clearBtn').disabled = !state;
      document.getElementById('deviceInfo').textContent = state ? 'Connected' : 'Web Serial API - Chrome/Edge required';
    }

    // ============================================
    // Serial Communication
    // ============================================
    async function toggleConnection() {
      if (connected) {
        await disconnect();
      } else {
        await connect();
      }
    }

    async function connect() {
      try {
        log('Requesting serial port...', 'info');
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200, dataBits: 8, stopBits: 1, parity: 'none' });

        writer = port.writable.getWriter();
        reader = port.readable.getReader();

        setConnected(true);
        log('Connected!', 'success');

        MUP1.reset();
        startReadLoop();

        // Send ping
        setTimeout(sendPing, 300);

      } catch (e) {
        log(`Connection failed: ${e.message}`, 'error');
      }
    }

    async function disconnect() {
      try {
        if (reader) { await reader.cancel(); reader.releaseLock(); }
        if (writer) { writer.releaseLock(); }
        if (port) { await port.close(); }
      } catch (e) {}
      port = null; writer = null; reader = null;
      setConnected(false);
      log('Disconnected', 'info');
    }

    async function startReadLoop() {
      try {
        while (connected) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value) {
            const hex = Array.from(value).slice(0,30).map(b => b.toString(16).padStart(2,'0')).join(' ');
            log(`RX: ${hex}${value.length > 30 ? '...' : ''}`, 'rx');

            const frames = MUP1.parse(value);
            for (const frame of frames) {
              handleFrame(frame);
            }
          }
        }
      } catch (e) {
        if (connected) log(`Read error: ${e.message}`, 'error');
      }
    }

    function handleFrame(frame) {
      if (frame.type === 'P') {
        const text = new TextDecoder().decode(frame.data);
        log(`PONG: ${text}`, 'success');
      } else if (frame.type === 'C') {
        const resp = CoAP.parseResponse(frame.data);
        if (resp) {
          if (resp.codeClass === 2) {
            log(`Response: ${resp.code} OK`, 'success');
          } else {
            log(`Response: ${resp.code} ERROR`, 'error');
          }
        }
      }
    }

    async function send(data) {
      if (!writer) return false;
      try {
        await writer.write(data);
        const hex = Array.from(data).slice(0,30).map(b => b.toString(16).padStart(2,'0')).join(' ');
        log(`TX: ${hex}${data.length > 30 ? '...' : ''}`, 'tx');
        return true;
      } catch (e) {
        log(`Send error: ${e.message}`, 'error');
        return false;
      }
    }

    async function sendPing() {
      await send(MUP1.createPing());
    }

    // ============================================
    // CBS Operations
    // ============================================
    async function applyCBS() {
      if (selectedPorts.size === 0) {
        log('Please select at least one port', 'error');
        return;
      }

      const tc = parseInt(document.getElementById('trafficClass').value);
      const idleSlope = parseInt(document.getElementById('idleSlope').value);

      log(`Applying CBS: TC${tc}, ${idleSlope} kbps to ${selectedPorts.size} ports`, 'info');

      for (const portNum of selectedPorts) {
        await applyCBSToPort(portNum, tc, idleSlope);
        await new Promise(r => setTimeout(r, 300));
      }

      log('CBS configuration complete', 'success');
    }

    async function applyCBSToPort(portNum, tc, idleSlope) {
      const payload = buildCBSPayload(String(portNum), tc, idleSlope);
      const coap = CoAP.buildFrame(CoAP.CODE_IPATCH, 'c', payload);
      const frame = MUP1.encode('c', coap);

      log(`Setting CBS on port ${portNum}: TC${tc}, ${idleSlope} kbps`, 'info');
      await send(frame);
    }

    async function clearCBS() {
      if (selectedPorts.size === 0) {
        log('Please select ports to clear', 'error');
        return;
      }

      const tc = parseInt(document.getElementById('trafficClass').value);
      log(`Clearing CBS TC${tc} on ${selectedPorts.size} ports`, 'info');

      for (const portNum of selectedPorts) {
        await clearCBSOnPort(portNum, tc);
        await new Promise(r => setTimeout(r, 300));
      }

      log('CBS cleared', 'success');
    }

    async function clearCBSOnPort(portNum, tc) {
      // To clear, send with null value
      const iid = [SID.TRAFFIC_CLASS_SHAPERS, String(portNum)];

      // Build CBOR: { IID => null }
      const result = [];
      result.push(0xa1);  // map(1)
      result.push(0x82);  // array(2)
      result.push(0x19, (SID.TRAFFIC_CLASS_SHAPERS >> 8) & 0xff, SID.TRAFFIC_CLASS_SHAPERS & 0xff);
      const nameBytes = new TextEncoder().encode(String(portNum));
      result.push(0x60 | nameBytes.length);
      result.push(...nameBytes);
      result.push(0xf6);  // null

      const payload = new Uint8Array(result);
      const coap = CoAP.buildFrame(CoAP.CODE_IPATCH, 'c', payload);
      const frame = MUP1.encode('c', coap);

      log(`Clearing CBS on port ${portNum}`, 'info');
      await send(frame);
    }

    // ============================================
    // Check Web Serial support
    // ============================================
    if (!('serial' in navigator)) {
      document.getElementById('connectBtn').disabled = true;
      document.getElementById('deviceInfo').textContent = 'Web Serial API not supported. Use Chrome or Edge.';
    }

    // Initialize
    initUI();
  </script>
</body>
</html>
