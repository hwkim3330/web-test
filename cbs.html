<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VelocityDRIVE-SP CBS Control</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
      min-height: 100vh;
      color: #fff;
      padding: 20px;
    }
    .container { max-width: 900px; margin: 0 auto; }
    header { text-align: center; margin-bottom: 30px; padding: 20px; }
    header h1 {
      font-size: 1.8rem;
      background: linear-gradient(90deg, #00d4ff, #7b2cbf);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    header p { color: #888; font-size: 0.85rem; margin-top: 8px; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    @media (max-width: 768px) { .grid { grid-template-columns: 1fr; } }
    .panel {
      background: rgba(255,255,255,0.03);
      border-radius: 16px;
      padding: 24px;
      border: 1px solid rgba(255,255,255,0.08);
    }
    .panel.full { grid-column: 1 / -1; }
    .panel h2 {
      font-size: 0.85rem;
      color: #00d4ff;
      margin-bottom: 16px;
      text-transform: uppercase;
      letter-spacing: 1px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #ff4757; }
    .status-dot.connected { background: #2ed573; }
    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.85rem;
      transition: all 0.2s;
      text-transform: uppercase;
    }
    .btn-primary { background: linear-gradient(135deg, #00d4ff, #0099cc); color: #000; }
    .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(0,212,255,0.3); }
    .btn-primary:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }
    .btn-danger { background: linear-gradient(135deg, #ff4757, #c0392b); color: #fff; }
    .btn-secondary { background: transparent; color: #888; border: 1px solid rgba(255,255,255,0.2); }
    .btn-secondary:hover { border-color: #00d4ff; color: #00d4ff; }
    .form-group { margin-bottom: 16px; }
    .form-group label { display: block; font-size: 0.75rem; color: #666; margin-bottom: 6px; text-transform: uppercase; }
    select, input[type="number"] {
      width: 100%;
      padding: 12px 16px;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      background: rgba(0,0,0,0.3);
      color: #fff;
      font-size: 1rem;
    }
    select:focus, input:focus { outline: none; border-color: #00d4ff; }
    .port-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; }
    .port-btn {
      padding: 14px 8px;
      background: rgba(255,255,255,0.03);
      border: 2px solid rgba(255,255,255,0.08);
      border-radius: 8px;
      color: #888;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.85rem;
      transition: all 0.2s;
    }
    .port-btn:hover { border-color: rgba(0,212,255,0.5); color: #fff; }
    .port-btn.selected { background: rgba(0,212,255,0.15); border-color: #00d4ff; color: #00d4ff; }
    .quick-btns { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 12px; }
    .quick-btn {
      padding: 6px 12px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 6px;
      color: #888;
      cursor: pointer;
      font-size: 0.75rem;
    }
    .quick-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
    .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .action-btns { display: flex; gap: 12px; margin-top: 20px; }
    .action-btns .btn { flex: 1; }
    .log-area {
      background: #0a0a0f;
      border-radius: 8px;
      padding: 16px;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 0.7rem;
      height: 250px;
      overflow-y: auto;
      border: 1px solid rgba(255,255,255,0.05);
      line-height: 1.6;
    }
    .log-line { margin-bottom: 2px; }
    .log-line.error { color: #ff6b6b; }
    .log-line.success { color: #51cf66; }
    .log-line.info { color: #74c0fc; }
    .log-line.tx { color: #fcc419; }
    .log-line.rx { color: #69db7c; }
    .log-line.debug { color: #da77f2; }
    .log-header { display: flex; justify-content: space-between; align-items: center; }
    .device-info { font-size: 0.75rem; color: #666; margin-top: 12px; padding: 8px 12px; background: rgba(0,0,0,0.2); border-radius: 6px; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>VelocityDRIVE-SP CBS Control</h1>
      <p>Credit Based Shaper Configuration via Web Serial</p>
    </header>

    <div class="grid">
      <div class="panel">
        <h2><span class="status-dot" id="statusDot"></span>Connection</h2>
        <button class="btn btn-primary" id="connectBtn" onclick="toggleConnection()">Connect Serial Port</button>
        <div class="device-info" id="deviceInfo">Web Serial API required (Chrome 89+ / Edge 89+)</div>
      </div>

      <div class="panel">
        <h2>Port Selection</h2>
        <div class="port-grid" id="portGrid"></div>
        <div class="quick-btns">
          <button class="quick-btn" onclick="selectPorts([1,2,3,4])">1-4</button>
          <button class="quick-btn" onclick="selectPorts([5,6,7,8])">5-8</button>
          <button class="quick-btn" onclick="selectPorts([9,10,11,12])">9-12</button>
          <button class="quick-btn" onclick="selectAllPorts()">All</button>
          <button class="quick-btn" onclick="clearPorts()">Clear</button>
        </div>
      </div>

      <div class="panel full">
        <h2>CBS Configuration</h2>
        <div class="form-row">
          <div class="form-group">
            <label>Traffic Class</label>
            <select id="trafficClass">
              <option value="7">TC 7 - Network Control</option>
              <option value="6">TC 6 - Voice</option>
              <option value="5">TC 5 - Video</option>
              <option value="4">TC 4 - Controlled Load</option>
              <option value="3">TC 3 - Excellent Effort</option>
              <option value="2">TC 2 - Spare</option>
              <option value="1">TC 1 - Background</option>
              <option value="0">TC 0 - Best Effort</option>
            </select>
          </div>
          <div class="form-group">
            <label>Idle Slope (kbps)</label>
            <input type="number" id="idleSlope" value="100000" min="0" max="1000000" step="1000">
          </div>
        </div>
        <div class="quick-btns" style="margin-bottom:12px">
          <button class="quick-btn" onclick="setIdleSlope(10000)">10 Mbps</button>
          <button class="quick-btn" onclick="setIdleSlope(50000)">50 Mbps</button>
          <button class="quick-btn" onclick="setIdleSlope(100000)">100 Mbps</button>
          <button class="quick-btn" onclick="setIdleSlope(250000)">250 Mbps</button>
          <button class="quick-btn" onclick="setIdleSlope(500000)">500 Mbps</button>
        </div>
        <div class="action-btns">
          <button class="btn btn-primary" id="applyBtn" onclick="applyCBS()" disabled>Apply CBS</button>
          <button class="btn btn-danger" id="clearBtn" onclick="clearCBS()" disabled>Clear CBS</button>
          <button class="btn btn-secondary" onclick="sendPing()">Ping</button>
        </div>
      </div>

      <div class="panel full">
        <div class="log-header">
          <h2>Log</h2>
          <button class="btn btn-secondary" onclick="clearLog()" style="padding:6px 12px;font-size:0.7rem">Clear</button>
        </div>
        <div class="log-area" id="logArea"></div>
      </div>
    </div>
  </div>

<script>
// =====================================================================
// YANG SID Definitions
// =====================================================================
const SID = {
  TRAFFIC_CLASS_SHAPERS: 8051,
  TRAFFIC_CLASS: 8052,
  CREDIT_BASED: 8053,
  IDLE_SLOPE: 8054,
};
const DELTA = {
  TC: SID.TRAFFIC_CLASS - SID.TRAFFIC_CLASS_SHAPERS,
  CB: SID.CREDIT_BASED - SID.TRAFFIC_CLASS_SHAPERS,
  IS: SID.IDLE_SLOPE - SID.CREDIT_BASED,
};

// =====================================================================
// MUP1 Protocol
// =====================================================================
const MUP1 = {
  SOF: 0x3e, EOF: 0x3c, ESC: 0x5c, ESC_00: 0x30, ESC_FF: 0x46,

  calcChecksum(data) {
    let sum = 0;
    for (let i = 0; i < data.length; i += 2) {
      const hi = data[i];
      const lo = (i + 1 < data.length) ? data[i + 1] : 0;
      sum += (hi << 8) | lo;
    }
    sum = ((sum >> 16) + (sum & 0xffff));
    sum = ((sum >> 16) + (sum & 0xffff));
    return ((~sum) & 0xffff).toString(16).padStart(4, '0');
  },

  encode(type, payload) {
    const rawFrame = [this.SOF, type.charCodeAt(0), ...payload, this.EOF];
    if (payload.length % 2 === 0) rawFrame.push(this.EOF);
    const checksum = this.calcChecksum(rawFrame);

    const frame = [this.SOF, type.charCodeAt(0)];
    for (const b of payload) {
      if (b === this.SOF || b === this.EOF || b === this.ESC) frame.push(this.ESC, b);
      else if (b === 0x00) frame.push(this.ESC, this.ESC_00);
      else if (b === 0xff) frame.push(this.ESC, this.ESC_FF);
      else frame.push(b);
    }
    frame.push(this.EOF);
    if (payload.length % 2 === 0) frame.push(this.EOF);
    for (const c of checksum) frame.push(c.charCodeAt(0));
    return new Uint8Array(frame);
  },

  createPing() { return this.encode('p', []); },

  state: 'IDLE', buffer: [],
  reset() { this.state = 'IDLE'; this.buffer = []; },

  parse(bytes) {
    const frames = [];
    for (const b of bytes) {
      switch (this.state) {
        case 'IDLE':
          if (b === this.SOF) { this.buffer = []; this.state = 'DATA'; }
          break;
        case 'DATA':
          if (b === this.ESC) this.state = 'ESCAPE';
          else if (b === this.EOF) this.state = 'EOF1';
          else this.buffer.push(b);
          break;
        case 'ESCAPE':
          if (b === this.ESC_00) this.buffer.push(0x00);
          else if (b === this.ESC_FF) this.buffer.push(0xff);
          else this.buffer.push(b);
          this.state = 'DATA';
          break;
        case 'EOF1':
          if (b === this.EOF) this.state = 'CHECKSUM';
          else if (/[0-9A-Fa-f]/.test(String.fromCharCode(b))) { this.state = 'CHECKSUM'; this.buffer.push(b); }
          else this.state = 'IDLE';
          break;
        case 'CHECKSUM':
          this.buffer.push(b);
          if (this.buffer.length >= 4) {
            frames.push({ type: String.fromCharCode(this.buffer[0]), data: new Uint8Array(this.buffer.slice(1, -4)) });
            this.state = 'IDLE'; this.buffer = [];
          }
          break;
      }
    }
    return frames;
  }
};

// =====================================================================
// CoAP Protocol
// =====================================================================
const CoAP = {
  CODE_IPATCH: 7,
  FORMAT_YANG_INSTANCES_CBOR: 142,
  msgId: Math.floor(Math.random() * 65536),

  buildFrame(method, path, payload = null) {
    const frame = [0x41, method];
    const msgId = this.msgId++ & 0xffff;
    frame.push((msgId >> 8) & 0xff, msgId & 0xff, 0x00);

    let lastOpt = 0;
    for (const p of path.split('/').filter(x => x)) {
      frame.push(((11 - lastOpt) << 4) | p.length);
      for (let i = 0; i < p.length; i++) frame.push(p.charCodeAt(i));
      lastOpt = 11;
    }

    if (payload) {
      frame.push(((12 - lastOpt) << 4) | 1, this.FORMAT_YANG_INSTANCES_CBOR);
      lastOpt = 12;
    }

    frame.push(((23 - lastOpt) << 4) | 1, 0x04);

    if (payload && payload.length > 0) {
      frame.push(0xff, ...payload);
    }
    return new Uint8Array(frame);
  },

  parseResponse(data) {
    if (data.length < 4) return null;
    const code = data[1];
    return {
      codeClass: (code >> 5) & 0x7,
      codeDetail: code & 0x1f,
      code: `${(code >> 5) & 0x7}.${(code & 0x1f).toString().padStart(2, '0')}`
    };
  }
};

// =====================================================================
// CBOR Encoder
// =====================================================================
function encodeCBOR(value) {
  const result = [];
  function encodeInt(v) {
    if (v < 24) result.push(v);
    else if (v < 256) result.push(0x18, v);
    else if (v < 65536) result.push(0x19, (v >> 8) & 0xff, v & 0xff);
    else result.push(0x1a, (v >> 24) & 0xff, (v >> 16) & 0xff, (v >> 8) & 0xff, v & 0xff);
  }
  function encode(v) {
    if (v === null || v === undefined) { result.push(0xf6); return; }
    if (typeof v === 'number' && Number.isInteger(v) && v >= 0) { encodeInt(v); return; }
    if (typeof v === 'string') {
      const bytes = new TextEncoder().encode(v);
      if (bytes.length < 24) result.push(0x60 | bytes.length);
      else result.push(0x78, bytes.length);
      result.push(...bytes);
      return;
    }
    if (Array.isArray(v)) {
      result.push(0x80 | v.length);
      for (const item of v) encode(item);
      return;
    }
    if (typeof v === 'object') {
      const keys = Object.keys(v).map(k => parseInt(k)).sort((a, b) => a - b);
      result.push(0xa0 | keys.length);
      for (const k of keys) { encodeInt(k); encode(v[k]); }
    }
  }
  encode(value);
  return result;
}

// =====================================================================
// CBS Payload Builders
// =====================================================================
function buildCBSPayload(portName, trafficClass, idleSlope) {
  const iidBytes = [0x82, 0x19, (SID.TRAFFIC_CLASS_SHAPERS >> 8) & 0xff, SID.TRAFFIC_CLASS_SHAPERS & 0xff];
  const nameBytes = new TextEncoder().encode(portName);
  iidBytes.push(0x60 | nameBytes.length, ...nameBytes);

  const entry = { [DELTA.TC]: trafficClass, [DELTA.CB]: { [DELTA.IS]: idleSlope } };
  const valueBytes = encodeCBOR([entry]);

  return new Uint8Array([0xa1, ...iidBytes, ...valueBytes]);
}

function buildCBSClearPayload(portName) {
  const result = [0xa1, 0x82, 0x19, (SID.TRAFFIC_CLASS_SHAPERS >> 8) & 0xff, SID.TRAFFIC_CLASS_SHAPERS & 0xff];
  const nameBytes = new TextEncoder().encode(portName);
  result.push(0x60 | nameBytes.length, ...nameBytes, 0xf6);
  return new Uint8Array(result);
}

// =====================================================================
// Application
// =====================================================================
let port = null, writer = null, reader = null, connected = false;
let selectedPorts = new Set();

function initUI() {
  const grid = document.getElementById('portGrid');
  for (let i = 1; i <= 12; i++) {
    const btn = document.createElement('button');
    btn.className = 'port-btn';
    btn.textContent = i;
    btn.onclick = () => { selectedPorts.has(i) ? selectedPorts.delete(i) : selectedPorts.add(i); btn.classList.toggle('selected'); };
    grid.appendChild(btn);
  }
  log('CBS Control ready. Connect to begin.', 'info');
}

function selectPorts(ports) { clearPorts(); const btns = document.querySelectorAll('.port-btn'); ports.forEach(p => { if (p >= 1 && p <= 12) { selectedPorts.add(p); btns[p-1].classList.add('selected'); } }); }
function selectAllPorts() { selectPorts([1,2,3,4,5,6,7,8,9,10,11,12]); }
function clearPorts() { selectedPorts.clear(); document.querySelectorAll('.port-btn').forEach(b => b.classList.remove('selected')); }
function setIdleSlope(v) { document.getElementById('idleSlope').value = v; }

function log(msg, type = '') {
  const area = document.getElementById('logArea');
  const time = new Date().toLocaleTimeString('en-US', { hour12: false });
  const line = document.createElement('div');
  line.className = 'log-line ' + type;
  line.textContent = `[${time}] ${msg}`;
  area.appendChild(line);
  area.scrollTop = area.scrollHeight;
  while (area.children.length > 300) area.removeChild(area.firstChild);
}
function logHex(prefix, data, type = '') {
  const hex = Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' ');
  log(`${prefix}: ${hex.slice(0, 80)}${hex.length > 80 ? '...' : ''} (${data.length}B)`, type);
}
function clearLog() { document.getElementById('logArea').innerHTML = ''; }

function setConnected(state) {
  connected = state;
  document.getElementById('statusDot').classList.toggle('connected', state);
  document.getElementById('connectBtn').textContent = state ? 'Disconnect' : 'Connect Serial Port';
  document.getElementById('applyBtn').disabled = !state;
  document.getElementById('clearBtn').disabled = !state;
  document.getElementById('deviceInfo').textContent = state ? 'Connected' : 'Web Serial API required (Chrome 89+ / Edge 89+)';
}

async function toggleConnection() { connected ? await disconnect() : await connect(); }

async function connect() {
  try {
    log('Requesting serial port...', 'info');
    port = await navigator.serial.requestPort();
    await port.open({ baudRate: 115200, dataBits: 8, stopBits: 1, parity: 'none', flowControl: 'none' });
    writer = port.writable.getWriter();
    reader = port.readable.getReader();
    setConnected(true);
    log('Connected', 'success');
    MUP1.reset();
    startReadLoop();
    setTimeout(sendPing, 500);
  } catch (e) { log(`Connection failed: ${e.message}`, 'error'); }
}

async function disconnect() {
  try {
    connected = false;
    if (reader) { await reader.cancel().catch(() => {}); reader.releaseLock(); }
    if (writer) { writer.releaseLock(); }
    if (port) { await port.close().catch(() => {}); }
  } catch (e) {}
  port = null; writer = null; reader = null;
  setConnected(false);
  log('Disconnected', 'info');
}

async function startReadLoop() {
  try {
    while (connected) {
      const { value, done } = await reader.read();
      if (done) break;
      if (value && value.length > 0) {
        logHex('RX', value, 'rx');
        const frames = MUP1.parse(value);
        for (const frame of frames) handleFrame(frame);
      }
    }
  } catch (e) { if (connected) log(`Read error: ${e.message}`, 'error'); }
}

function handleFrame(frame) {
  if (frame.type === 'P') {
    const text = new TextDecoder().decode(frame.data);
    const parts = text.split(' ');
    log(`PONG: ${parts[0] || 'N/A'}, uptime=${parts[1] || '?'}s`, 'success');
  } else if (frame.type === 'C') {
    const resp = CoAP.parseResponse(frame.data);
    if (resp) {
      const desc = resp.codeClass === 2 ? 'OK' : 'Error';
      log(`CoAP ${resp.code} ${desc}`, resp.codeClass === 2 ? 'success' : 'error');
    }
  } else if (frame.type === 'T') {
    log(`TRACE: ${new TextDecoder().decode(frame.data)}`, 'debug');
  }
}

async function send(data) {
  if (!writer) { log('Not connected', 'error'); return false; }
  try { await writer.write(data); logHex('TX', data, 'tx'); return true; }
  catch (e) { log(`Send error: ${e.message}`, 'error'); return false; }
}

async function sendPing() { log('Ping...', 'info'); await send(MUP1.createPing()); }

async function applyCBS() {
  if (selectedPorts.size === 0) { log('Select ports first', 'error'); return; }
  const tc = parseInt(document.getElementById('trafficClass').value);
  const idleSlope = parseInt(document.getElementById('idleSlope').value);
  const ports = Array.from(selectedPorts).sort((a, b) => a - b);

  log(`Applying CBS: ports=[${ports}], TC${tc}, ${idleSlope}kbps`, 'info');

  for (const p of ports) {
    const payload = buildCBSPayload(String(p), tc, idleSlope);
    log(`Port ${p} CBOR: ${Array.from(payload).map(b => b.toString(16).padStart(2,'0')).join(' ')}`, 'debug');
    const coap = CoAP.buildFrame(CoAP.CODE_IPATCH, 'c', payload);
    await send(MUP1.encode('c', coap));
    await new Promise(r => setTimeout(r, 400));
  }
  log('CBS applied', 'success');
}

async function clearCBS() {
  if (selectedPorts.size === 0) { log('Select ports first', 'error'); return; }
  const ports = Array.from(selectedPorts).sort((a, b) => a - b);
  log(`Clearing CBS: ports=[${ports}]`, 'info');

  for (const p of ports) {
    const payload = buildCBSClearPayload(String(p));
    const coap = CoAP.buildFrame(CoAP.CODE_IPATCH, 'c', payload);
    await send(MUP1.encode('c', coap));
    await new Promise(r => setTimeout(r, 400));
  }
  log('CBS cleared', 'success');
}

if (!('serial' in navigator)) {
  document.getElementById('connectBtn').disabled = true;
  document.getElementById('deviceInfo').innerHTML = '<span style="color:#ff6b6b">Web Serial not supported!</span>';
}
initUI();
</script>
</body>
</html>
